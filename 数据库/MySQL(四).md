# 查询性能优化

## 1. 优化数据访问的案例和指标

常见的可优化案例如下：

- **查询不需要的记录**
- **多表关联时返回全部列**
- **总是取出全部列**
- **重复查询相同的数据**

对于 MySQL ，最简单的衡量查询开销的三个指标是 **响应时间(I/O或者锁等待时长+真正处理时长)**、**扫描的行数**、**返回的行数** 。它们大致反映了 MySQL 在内部执行查询时需要访问多少数据，并可以大概推算出查询运行的时间。

## 2. 重构查询的方式

### 2.1 衡量一个复杂的查询还是多个简单的查询

为什么说是衡量呢？主要是对于不同业务场景的需求会有不同的处理方式，若是对延时敏感则可以把一个复杂的查询拆为多个简单的查询，因为多个查询对于 MySQL 服务端压力并不是太大，一个千兆网卡可以轻松满足每秒2000+次查询。相比之下， MySQL 响应数据可能就会慢的多。而对于一些不关心延时的场景，考虑代码可维护性一个复杂的查询也是没有任何问题的。

### 2.2 切分查询

大的查询切分为多个小查询，可以有效的把压力分散到一个很长的时间段。对于一些辅助操作(例如定期删除数据)可以把压力分散到多个时间段。

### 2.3 分解关联查询

对于现代互联网架构，都会有缓存模块。我们把一个复杂的关联的查询分解为多个单表查询可以更有效的减少粒度增加缓存的命中率。而且单个查询可以降低锁的竞争，应用层做关联也可以更灵活。

## 3. 查询执行的基础

<img src="http://qiniu.itliusir.com/mysql03.png" style="zoom:70%;" />

上图是一个请求经过 MySQL 的过程：

1. 客户端发送一个查询语句给服务器
2. 服务器先检查缓存模块(高版本已取消该模块)，命中缓存就直接返回，否则进入下一阶段
3. 服务器端进行 SQL 解析、预处理、再交给优化器生成对应执行计划
4. MySQL 根据执行计划调用存储引擎的 API 来执行查询
5. 结果返回给客户端

### 3.1 MySQL C/S 通信协议

TODO //有时间单独写一篇

### 3.2 查询缓存

在解析一个查询语句之前，如果服务端支持缓存模块，会先检查这个查询是否命中查询缓存中的数据。检查的手段是对 **大小敏感** 的哈希查找实现的。

### 3.3 查询优化处理

该阶段主要是把一个 SQL 转换为一个执行计划，MySQL 再按照这个执行计划和存储引擎进行交互，这里会分为三个子阶段：**解析SQL** 、**预处理** 、**优化 SQL 执行计划** 。整个过程中任何错误都可能终止查询。

#### 3.3.1 解析SQL

MySQL 通过关键字将 SQL 语句进行解析，并生成一棵对应的 “解析树”。然后解析器将使用 MySQL 语法规则验证和解析查询。

#### 3.3.2 预处理

根据 MySQL 规则进一步检查解析树是否合法(表列是否存在、名字别名是否有歧义等)

#### 3.3.3 优化计划

此时语法树被认为是合法的，并且由优化器将其转化为执行计划。每条查询都可以有多种执行方式，最后返回相同的结果，优化器作用是找到这其中最好的执行计划。

- **基于成本的优化**

  成本主要体现为2个方面：**I/O 成本** 和 **CPU成本**。我们常用的 InnoDB 存储引擎都是将数据和索引都存储在磁盘上，我们想要查询时，需要先把数据或索引加载到内存中然后再操作，磁盘到内存的加载过程时间成本就是 **I/O 成本** ；而对结果集进行排序等操作时间成本就是 **CPU 成本**。

  MySQL 采用基于成本(I/O成本、CPU成本)的优化器，其规定读取一个页(磁盘和内存交互的基本单位)花费的成本默认是 1.0，读取和检测一条记录是否符合搜索条件成本默认是 0.2。1.0 0.2这些数字称为 **成本常数** 。

  例如我们一般的查询语句过程如下：

  1. 根据搜索条件，找出所有可能使用的索引(假设可以使用二级索引idx_age)
  2. 计算全表扫描的代价(假设表10000条记录，占用了100个页，I/O 成本 = 100 * 1.0 + 微调 ≈ 100；CPU 成本 = 10000 * 0.2 + 微调 ≈ 2000；全表扫描总成本也即是 2100)
  3. 计算使用不同索引执行查询的代价，查询优化器认为一个范围区间查询的I/O成本相当于读取一个页面，而每次回表的 I/O成本也相当于读取一个页面。(假设idx_age只有一个范围区间查询，区间内有100条记录，I/O 成本 = 1 * 1.0(范围查询成本) + 100 * 1.0(回表成本) + 微调 ≈ 101；CPU 成本 = 100 * 0.2(读取二级索引成本) + 100 * 0.2(还需要检测聚簇索引成本) + 微调 ≈ 40；按照idx_age索引总成本也即是141)
  4. 对比各种方案的代价，找出成本最低的(我们这个例子可以明显看出选idx_age索引最优)

  > 当然有很多原因都会导致优化器选择错误的执行计划，例如统计信息不准、成本预估只是参考、模型还不够完美、无法估算所有可能的执行计划。

### 3.4 查询执行引擎

MySQL 只是简单的根据执行计划给出的指令逐步执行，然后大量的操作通过调用存储引擎实现的接口来完成。

### 3.5 返回结果给客户端

如果查询可以被缓存，那么 MySQL 在这个阶段会把结果存放到查询缓存中。

MySQL 将结果集返回客户端是逐步增量，这样服务器无需存储太多的结果，也不会消耗大量内存，这样处理客户端会第一时间获得返回的结果。



> 本系列着重记录基础知识，具体场景优化系列暂不在此写入。