# 查询性能优化

## 1. 优化数据访问的案例和指标

常见的可优化案例如下：

- **查询不需要的记录**
- **多表关联时返回全部列**
- **总是取出全部列**
- **重复查询相同的数据**

对于 MySQL ，最简单的衡量查询开销的三个指标是 **响应时间(I/O或者锁等待时长+真正处理时长)**、**扫描的行数**、**返回的行数** 。它们大致反映了 MySQL 在内部执行查询时需要访问多少数据，并可以大概推算出查询运行的时间。

## 2. 重构查询的方式

### 2.1 衡量一个复杂的查询还是多个简单的查询

为什么说是衡量呢？主要是对于不同业务场景的需求会有不同的处理方式，若是对延时敏感则可以把一个复杂的查询拆为多个简单的查询，因为多个查询对于 MySQL 服务端压力并不是太大，一个千兆网卡可以轻松满足每秒2000+次查询。相比之下， MySQL 响应数据可能就会慢的多。而对于一些不关心延时的场景，考虑代码可维护性一个复杂的查询也是没有任何问题的。

### 2.2 切分查询

大的查询切分为多个小查询，可以有效的把压力分散到一个很长的时间段。对于一些辅助操作(例如定期删除数据)可以把压力分散到多个时间段。

### 2.3 分解关联查询

对于现代互联网架构，都会有缓存模块。我们把一个复杂的关联的查询分解为多个单表查询可以更有效的减少粒度增加缓存的命中率。而且单个查询可以降低锁的竞争，应用层做关联也可以更灵活。

## 3. 查询执行的基础

<img src="http://qiniu.itliusir.com/mysql03.png" style="zoom:70%;" />

上图是一个请求经过 MySQL 的过程：

1. 客户端发送一个查询语句给服务器
2. 服务器先检查缓存模块(高版本已取消该模块)，命中缓存就直接返回，否则进入下一阶段
3. 服务器端进行 SQL 解析、预处理、再交给优化器生成对应执行计划
4. MySQL 根据执行计划调用存储引擎的 API 来执行查询
5. 结果返回给客户端

### 3.1 MySQL C/S 通信协议

TODO

### 3.2 查询缓存



### 3.3 查询优化处理



### 3.4 查询执行引擎



### 3.5 返回结果给客户端

