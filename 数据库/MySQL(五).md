# 复制

## 1. 概述

MySQL 的复制是用来构建大规模、高性能不可或缺的基础，主要分为两种复制：

- **基于语句的复制**

  优点：语句相对实现简单，占用内存也小，发生的变更更容易理解，出现问题更好定位。

  缺点：对一些元数据信息(例如时间戳)、触发器、存储过程会存在问题

- **基于行的复制**

  优点：场景覆盖足，更高效复制数据，重放开销相对小一些

  缺点：对于全表更新这种，占用内存更大，黑盒子很难定位问题所在。

MySQL 的复制大部分是向后兼容的，也即是你可以使用新的版本来作为老版本的备库。通过复制可以把读操作指向备库来获得更好的扩展，但是对写操作并没有增加很好的扩展反而带来了很多的开销。

> 这里的开销是指备库请求主库网络 I/O 的开销，也指唤醒多个复制线程的开销

下面我们来分析 MySQL 的复制是如何工作的。

1. 主库在事务执行的过程中先把日志写入到 binlog cache，事务提交的时候把binlog cahce记录在 binlog文件中(cache刷盘时机可以通过sync_binlog参数控制，为0就是只写入cache不记录到文件，为1是每次cache都记录到文件，为N就是N个事务cache后才会记录到文件)
2. 备库把主库的binlog复制到自己的relaylog(中继日志)。首先备库会启动一个工作 I/O 线程与主库建立连接，主库也会创建启动一个线程来监听binlog并传输数据，备库的 I/O 线程会把收到的数据记录到中继日志。
3. 备库读取relaylog，重放到备库数据上

<img src="http://qiniu.itliusir.com/mysql04.png" alt="" style="zoom:50%;" />

这种架构实现了获取事件和重放事件的解耦，允许两个线程异步进行，但是这种架构也限制了复制的过程，主库的并发记录在备库重放只能串行化执行，因为备库的重放只有一个 I/O线程。

## 2. 复制拓扑

### 2.1 一主多备

最简单的拓扑结构，在少量写大量读时，很有效。会把读压力分摊到多个备库上面去，直到备库太多给主库造成负担或者带宽瓶颈为止。

### 2.2 双主模式下的主-主复制

主-主复制，每个主都配置成对方的主库和备库。

这样会出现很多问题，例如在两个主库同时更新同一列时，这种情况解决比较困难，所以我们如果能很好的划分数据和权限并且清楚自己在做什么，可以避免这些问题。

### 2.3 主动-被动模式下的主-主复制

与上述的双主模式的区别是，主动-被动模式是把被动服务器设置为只读，把每个主库只设置为对方的备库。

这种拓扑结构类似创建了一个热备份，可以反复的切换。

### 2.4 拥有备库的主-主复制

在每个主库增加了一个备库，属于主-主复制架构中的一种冗余，增加了可用性。但是会增加维护的复杂度。

### 2.5 主备模式-分发主库

当备库比较多会对主库造成很大负载，备库如果请求大的时间也会有很大负载，而且备库如果请求数据不在文件缓存中，会造成大量的磁盘检索影响主库的性能。

所以我们可以增加一个主库的备库(分发主库)，这个主库的备库提供主库的二进制文件，多个备库连接到这个备库(分发主库)上，降低主库的负担。

如果需要的话也可以使用多个分发主库或者金字塔状的分发主库。这样设计可以减轻主库的负担，缺点是中间层次越多，处理故障也就越复杂。

### 2.6 自定义复制方案

我们可以根据业务的规则，让每个备库只拥有主库的一部分数据，备库也是只读的，这样可以更好的利用备库的内存，也可以保障主库在多个备库的负载压力减少。

把数据水平划分后，我们可以定义不同业务规则访问哪个备库，特殊情况在读操作没找到数据的时候再去通过主库来查。