# 创建高性能索引

## 1. 索引基础

索引有很多种类型，在 MySQL 中索引是存储引擎层而不是服务端实现的，所以不同的存储引擎的索引底层也不同。

### 1.1 B+ Tree 索引

InnoDB 使用的是 B+ Tree 索引，属于 B Tree 的变种。其只在叶子节点存放数据，普通节点只存放k和页号。所以树的高度不会太高，又因为其索引列是顺序组织存储所以很适合范围查找。通过下图可以清晰的看到主键索引和普通索引存储数据的区别，主键索引组织真正的数据，而普通列索引存放的是主键的值，所以查询普通列索引会多一次回表操作(先从普通索引树读到k=3的记录取到主键id为300，然后去主键ID索引树查到对应的值记录R3)。

<img src="http://qiniu.itliusir.com/mysql02.png" style="zoom:50%;" />

### 1.2 hash 索引

hash 索引是基于哈希表实现，只有精确匹配所有列才会精确查询到。MySQL 的 Memory 引擎默认的就是 hash 索引。好处就是查找对比B Tree这种索引速度飞快。

由此可以推导出 hash 索引的一些不足之处：

1. 并不是顺序存储，所以无法排序
2. 不支持部分索引匹配查找
3. 只支持等值查询不支持范围查询
4. hash冲突严重会退化时间复杂度(查找，删除)

## 2. 索引的优点

- **减少查数据的时间**

  例如 B+ Tree 其二分查询只需要寻块几次就可以找到对应数据，减少了整体的查询时间。

- **随机 I/O 变成 顺序 I/O**

  索引列顺序存储

## 3. 高性能的索引策略

- **独立的列不能是表达式的一部分**

  如下面这样，虽然等价于直接等于4，但是无法使用 `user_id` 索引

  ```mysql
  mysql> select user_id from user where user_id + 1 = 5
  ```

- **计算合适的前缀长度/计算完整列的选择性**

  先说下什么是 **选择性？**

  > 索引的选择性是指，不重复的索引值(基数) 和 数据表的记录总数(T)的比值，也即是 1/T 到 1。
  >
  > 选择性越高就会过滤更多行，唯一索引选择性就是最高，也是性能最好的，它的选择性为1。

  所以，对于一个索引很长的字符列，我们一般有两种方法：

  1. 逐渐增加前缀长度，直到这个前缀选择性接近完整列的选择性
  2. 直接计算完整列的选择性，也是对不同前缀长度进行计算，通过查看是否接近 0.031(经验值)来判断可用

- **多列索引**
  - 当出现服务器对多个索引做相交操作(AND)，通常意味着需要一个包含所以相关列的多列索引
  - 当出现服务器对多个索引做联合操作(OR)，通常需要耗费大量 CPU、内存在算法的缓存、排序和合并操作。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据时候。
  - 更重要的是，优化器不会把这些计算到 ”查询成本“ 中，优化器只关心随机页面读取。导致该执行计划还不如走全表扫描。

- **选择合适的索引列顺序**

  当不需要考虑排序和分组时，把选择性最高的列放到索引最前列通常是最好的。

## 4. 聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。聚集数据的好处是可以减少随机磁盘 I/O 的次数使数据访问更快。

同样，任何方式都有缺点，聚簇索引的缺点主要体现在更新维护代价，因为每次插入或者更新都要维护页中的数据。有可能就会面临 ”页分裂“ 。还有就是对二级索引(普通列，非聚簇索引)的查询都需要两次索引查找(二级索引中保存的是聚簇索引的记录行)

## 5. 覆盖索引

覆盖索引主要目的就是类似聚簇索引 ，把想要查的数据放在索引列里，这样就不用回表啦。