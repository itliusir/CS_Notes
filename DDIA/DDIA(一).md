# 数据系统和数据模型

## 1. 数据系统

现如今我们大多数应用程序都是**数据密集型**，而非**计算密集型** 

近些年，我们会把数据库、消息队列、缓存等称为**数据系统** ，这并不是突然的混为一谈，而且这些之间的界限越来越模糊，例如我们可以使用数据存储系统redis做消息队列，而消息队列又会有类似数据库的持久保证。

>  所以我们很多的组件的底层设计都是相同设计的，然后根据组件的定位去延展对应的属性。

<img src="http://qiniu.itliusir.com/ddia1.png" style="zoom:50%;" />

如上所示，这是一个很常见的数据系统，我们使用了cache做缓存，未命中则走数据库，数据库更新后同步ES维护索引，还扩展了异步的任务接口。

接下来我们介绍下三个在经常会在设计数据系统中考虑的指标

- **可靠性** 即使出现故障(硬件、软件、人为)，也能继续正确工作
- **可扩展性** 系统应对负载增长能力的术语，主要考虑的是应对增长的能力
- **可维护性** 运维团队可以保障、系统尽量简单轻松理解、新场景适配可扩展



## 2. 数据模型

一个复杂的应用程序可能会有更多的中间层次、比如通过一个明确的API or 数据模型来隐藏更底层的复杂性。

### 2.1 关系模型和文档模型

我们参考数据库mysql 和 MongoDB 的设计，这个很好理解。而我本人所处的业务领域(没那么复杂的关系)来说，更喜欢使用 MongoDB 这种模型，减少了一些笨拙的转换层。

而对于目前的一些新型的数据库都是既支持行存储，也支持列存储。这就对于业务的支撑更加的灵活，界限也并没有那么的单一。而从 mysql 5.7+开始支持json文档也可以看出，这两者并不是明确的界限。

### 2.2 查询语言

除了我们的声明式查询语言 SQL外，还有一些使用 **命令式(API)** 来查询数据库。

还有一些例如 MapReduce 既不是声明式SQL 也不是完全命令式查询API，而是处于之间(混合)，查询逻辑可以用代码片段运行。而再上层也可以使用声明式SQL来定义task(参考spark sql)。

### 2.3 图数据模型

对于一些数据之间关系很复杂，那将数据建模为图形则更自然。一个图由两种对象构成：**顶点** 和 **边** 。

典型的场景如下：

- **社交图谱**
- **网络图谱**
- **公路或铁路网络**
- ...

每个**顶点**包括了：

- 唯一的标识符
- 一组 出边
- 一组 入边
- 一组键值对

每条**边**包括了：

- 唯一的标识符
- 边的起点/尾部顶点
- 边的终点/头部顶点
- 描述两个顶点之间关系类型的标签
- 一组键值对